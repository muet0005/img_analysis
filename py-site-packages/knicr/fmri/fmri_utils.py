import os as os
import sys as sys
import csv as csv
from nibabel import nifti1 as nii
import numpy as np
import random

__author__ = "Ryan Muetzel"
__license__ = "GPL"
__version__ = "0.2"


def calc_nvols(self, fmriniis):
	if type(fmriniis) is list:
		niiFile = fmriniis[0]
	else:
		niiFile = fmriniiis
	if os.path.exists(niiFile):
		n = nii.load(niiFile)
		dims = n.get_shape()
		t = dims[3]
	else:
		t = False
	return t


class genFSLfsf():
	"""
	Class for generating  FSL MELODIC FSF files
	
	The initialization takes 3 required arguments (i.e., the ones that don't have defaults):
	
	fsfFile = the name of the resulting fsfFile
	
	fmriniis = a single string fmri nifti file path, or a list of multiple paths to nifti files.	
	
	standard_brain = the path and file name of the standard space brain you're using.  
		
	**Option arguments:
	
	config='/path_to_your_configuration_file/config.txt'
	
	A file can be read in that will overwrite a number of defaults such as te, tr, standard_brain, etc.
	This file would have values that look like this:
	
	tr=2.0
	te=30
	regstandard=/home/fsl/data/standard/mni_152_t1_1mm_brain.nii.gz
	
	Most options have the same variable names as the ones you find in FSL's fsf files for feat.
	
	highresniis = a path to a single structural high res image, or a list with multiple.  THIS MUST MATCH SUBJECT ID ORDER OF THE FMRINII LIST!
	
	"""
	def __init__(self, fsfFile, fmriniis, outdir, standard_brain, **kwargs):
		self.fsfFile = fsfFile; self.fmriniis = fmriniis; self.outdir = outdir, self.standard_brain = standard_brain
		#set a few default options.  These are overwirtten if specified via a config file
		self.cluster = True
		self.tr = 2.0; self.te = 30
		###feat-specific options###
		if not self.cluster:
			self.featwatcher = True
		else:
			self.featwatcher = False
		self.sscleanup = False
		self.ndelete = 4
		self.smooth = 8
		self.reghighres = False
		self.regstandard = '\"' + standard_brain + '\"'
		self.dim = False
		self.ndimensions = 16
		self.reghighres_search = 180
		self.regstandard_search = 90
		self.regstandard_nonlinear_yn = False
		self.analysis = 7
		#read in passed arguments...overwrite these defaults if needed.
		for i in kwargs.keys():
			if i == 'config':
				config_file = open(kwargs[i], 'r')
				for args in config_file:
					arg,val = args.strip('\n').split('=')
					if arg == 'tr':
						self.tr = val
					elif arg == 'te':
						self.te = val
					elif arg == 'cluster':
						self.cluster = bool(val)
					elif arg == 'sscleanup':
						self.sscleanup = bool(val)
					elif arg == 'ndelete':
						self.ndelete = val
					elif arg == 'smooth':
						self.smooth = val
					elif arg == 'reghighres':
						self.reghighres = bool(val)
					elif arg == 'regstandard':
						self.regstandard = '\"' + val + '\"'
					elif arg == 'dim':
						self.dim = bool(val)
					elif arg == 'ndimensions':
						self.ndimensions = val
					elif arg == 'reghighres_search':
						self.reghighres_search = val
					elif arg == 'regstandard_search':
						self.regstandard_search = val
					elif arg == 'regstandard_nonlinear_yn':
						self.regstandard_nonlinear_yn = val
					elif arg == 'analysis':
						self.analysis = val
				config_file.close()
			elif i == 'highresniis':
				self.highresniis = kwargs[i]
				if not self.highresniis == False
					self.reghighres = True
	
	def genFeatfsf(self):
		nvols = calc_nvols(fmriniiis)
		if not nvols:
			print "cannot find nifti volume to calculate number of TRs...must exit..."
			sys.exit(0)
		fsf = []
		fsf.append('set fmri(version) 6.00' + '\n')
		fsf.append('set fmri(inmelodic) 0' + '\n')
		fsf.append('set fmri(level) 1' + '\n')
		fsf.append('set fmri(analysis) ' + str(self.analysis) + '\n')
		fsf.append('set fmri(relative_yn) 0' + '\n')
		fsf.append('set fmri(help_yn) 1' + '\n')
		fsf.append('set fmri(featwatcher_yn) ' + str(int(self.featwatcher)) + '\n')
		fsf.append('set fmri(sscleanup_yn) ' + str(int(self.sscleanup)) + '\n')
		fsf.append('set fmri(outputdir) \"' + outputdir + '\"' + '\n')
		fsf.append('set fmri(tr) ' + str(self.tr) + '\n')
		fsf.append('set fmri(npts) ' + str(nvols) + '\n')
		fsf.append('set fmri(ndelete) ' + str(self.ndelete) + '\n')
		fsf.append('set fmri(tagfirst) 1' + '\n')
		if type(self.fmriniis) is list:
			fsf.append('set fmri(multiple) ' + str(len(self.fmriniis)) + '\n')
		else:
			fsf.append('set fmri(multiple) 1' + '\n')
		fsf.append('set fmri(inputtype) 1' + '\n')
		prestats = {1: True, 2: False, 3: True, 4: False, 6: False, 7: True}
		fsf.append('set fmri(filtering_yn) 1' + '\n')
		fsf.append('set fmri(brain_thresh) 10' + '\n')
		fsf.append('set fmri(critical_z) 5.3' + '\n')
		fsf.append('set fmri(noise) 0.66' + '\n')
		fsf.append('set fmri(noisear) 0.34' + '\n')
		fsf.append('set fmri(newdir_yn) 0' + '\n')
		fsf.append('set fmri(mc) 1' + '\n')
		fsf.append('set fmri(sh_yn) 0' + '\n')
		#TODO: need to work code in for this in the future; possibly consider using xnat dcm data base for params
		fsf.append('set fmri(regunwarp_yn) 0' + '\n')
		fsf.append('set fmri(dwell) 0.7' + '\n')
		fsf.append('set fmri(te) ' + str(self.te) + '\n')
		fsf.append('set fmri(signallossthresh) 10' + '\n')
		fsf.append('set fmri(unwarp_dir) y-' + '\n')
		fsf.append('set fmri(st) 0' + '\n')
		fsf.append('set fmri(st_file) \"\"' + '\n')
		fsf.append('set fmri(bet_yn) 1' + '\n')
		fsf.append('set fmri(smooth) ' + str(self.smooth) + '\n')
		fsf.append('set fmri(norm_yn) 0' + '\n')
		fsf.append('set fmri(perfsub_yn) 0' + '\n')
		fsf.append('set fmri(temphp_yn) 1' + '\n')
		fsf.append('set fmri(templp_yn) 0' + '\n')
		fsf.append('set fmri(melodic_yn) 0' + '\n')
		fsf.append('set fmri(stats_yn) 1' + '\n')
		fsf.append('set fmri(prewhiten_yn) 1' + '\n')
		fsf.append('set fmri(motionevs) 0' + '\n')
		fsf.append('set fmri(robust_yn) 0' + '\n')
		fsf.append('set fmri(mixed_yn) 2' + '\n')
		fsf.append('set fmri(evs_orig) 1' + '\n')
		fsf.append('set fmri(evs_real) 2' + '\n')
		fsf.append('set fmri(evs_vox) 0' + '\n')
		fsf.append('set fmri(ncon_orig) 1' + '\n')
		fsf.append('set fmri(ncon_real) 1' + '\n')
		fsf.append('set fmri(nftests_orig) 0' + '\n')
		fsf.append('set fmri(nftests_real) 0' + '\n')
		fsf.append('set fmri(constcol) 0' + '\n')
		poststats = {1: False, 2: False, 3: False, 4: True, 6: True, 7: True}
		fsf.append('set fmri(poststats_yn) ' + str(int(poststats[analysis])) + '\n')
		fsf.append('set fmri(threshmask) \"\"' + '\n')
		fsf.append('set fmri(thresh) 3' + '\n')
		fsf.append('set fmri(prob_thresh) 0.05' + '\n')
		fsf.append('set fmri(z_thresh) 2.3' + '\n')
		fsf.append('set fmri(zdisplay) 0' + '\n')
		fsf.append('set fmri(zmin) 2' + '\n')
		fsf.append('set fmri(zmax) 8' + '\n')
		fsf.append('set fmri(rendertype) 1' + '\n')
		fsf.append('set fmri(bgimage) 1' + '\n')
		fsf.append('set fmri(tsplot_yn) 1' + '\n')
		fsf.append('set fmri(reg_yn) 1' + '\n')
		fsf.append('set fmri(reginitial_highres_yn) 0' + '\n')
		fsf.append('set fmri(reginitial_highres_search) 90' + '\n')
		fsf.append('set fmri(reginitial_highres_dof) 3' + '\n')
		fsf.append('set fmri(reghighres_yn) ' + str(int(self.reghighres)) + '\n')
		fsf.append('set fmri(reghighres_search) ' + str(self.reghighres_search) + '\n')
		fsf.append('set fmri(reghighres_dof) 6' + '\n')
		fsf.append('set fmri(regstandard_yn) 1' + '\n')
		fsf.append('set fmri(regstandard) ' + self.regstandard + '\n')
		fsf.append('set fmri(regstandard_search) ' + str(self.regstandard_search) + '\n')
		fsf.append('set fmri(regstandard_dof) 12' + '\n')
		fsf.append('set fmri(regstandard_nonlinear_yn) ' + str(int(self.regstandard_nonlinear_yn)) + '\n')
		fsf.append('set fmri(regstandard_nonlinear_warpres) 10' + '\n')
		fsf.append('set fmri(paradigm_hp) 100' + '\n')
		fsf.append('set fmri(ncopeinputs) 0' + '\n')			
		if not type(self.fmriniis) is list:
			fsf.append('set feat_files(1) \"' + self.fmriniis + '\"\n')
		else:
			for i in range(1, len(self.fmriniis)+1):
				 fsf.append('set feat_files(' + str(i) + ') \"' + self.fmriniis[i-1] + '\"\n')
		fsf.append('set fmri(confoundevs) 0' + '\n')
		if self.reghighres:
			if not type(self.highresniis) is list:
				fsf.append('set highres_files(1) \"' + self.highresniis + '\"')
			else:
				for i in range(1, len(self.highresniis)+1):
					fsf.append('set highres_files(' + str(i) + ') \"' + self.highresniis[i-1] + '\"')
		fsf.append('set fmri(evtitle1) \"\"' + '\n')
		fsf.append('set fmri(shape1) 0' + '\n')
		fsf.append('set fmri(convolve1) 2' + '\n')
		fsf.append('set fmri(convolve_phase1) 0' + '\n')
		fsf.append('set fmri(tempfilt_yn1) 1' + '\n')
		fsf.append('set fmri(deriv_yn1) 1' + '\n')
		fsf.append('set fmri(skip1) 0' + '\n')
		fsf.append('set fmri(off1) 30' + '\n')
		fsf.append('set fmri(on1) 30' + '\n')
		fsf.append('set fmri(phase1) 0' + '\n')
		fsf.append('set fmri(stop1) -1' + '\n')
		fsf.append('set fmri(gammasigma1) 3' + '\n')
		fsf.append('set fmri(gammadelay1) 6' + '\n')
		fsf.append('set fmri(ortho1.0) 0' + '\n')
		fsf.append('set fmri(ortho1.1) 0' + '\n')
		fsf.append('set fmri(con_mode_old) orig' + '\n')
		fsf.append('set fmri(con_mode) orig' + '\n')
		fsf.append('set fmri(conpic_real.1) 1' + '\n')
		fsf.append('set fmri(conname_real.1) \"\"' + '\n')
		fsf.append('set fmri(con_real1.1) 1' + '\n')
		fsf.append('set fmri(con_real1.2) 0' + '\n')
		fsf.append('set fmri(conpic_orig.1) 1' + '\n')
		fsf.append('set fmri(conname_orig.1) \"\"' + '\n')
		fsf.append('set fmri(con_orig1.1) 1' + '\n')
		fsf.append('set fmri(conmask_zerothresh_yn) 0' + '\n')
		fsf.append('set fmri(conmask1_1) 0' + '\n')
		fsf.append('set fmri(thresh_yn) 1' + '\n')
		fsf.append('set fmri(mmthresh) 0.5' + '\n')
		fsf.append('set fmri(ostats) 0' + '\n')
		fsf.append('set fmri(ts_model_mat) \"\"' + '\n')
		fsf.append('set fmri(ts_model_con) \"\"' + '\n')
		fsf.append('set fmri(subject_model_mat) \"\"' + '\n')
		fsf.append('set fmri(subject_model_con) \"\"' + '\n')
		fsf.append('set fmri(alternative_example_func) \"\"' + '\n')
		fsf.append('set fmri(alternative_mask) \"\"' + '\n')
		fsf.append('set fmri(init_initial_highres) \"\"' + '\n')
		fsf.append('set fmri(init_highres) \"\"' + '\n')
		fsf.append('set fmri(init_standard) \"\"' + '\n')
		fsf.append('set fmri(overwrite_yn) 0' + '\n')
		f = open(self.fsfFile, 'w')
		f.writelines(fsf)
		f.close()
	


class gen_bootstrap_samples():
	"""
	Class to generate random list of subjects for melodic analyses
	
	Functions include:
	
	read_subj_list to read a list of Rnumbers/IDCs
	
	gen_samples to generate the list of random id numbers
	
	gen_melodic_lisa to generate a text file to be passed to FSLs melodic command line.
	"""
	def __init__(self):
		self.subjs = []
		self.samples = []
	
	def read_subj_list(self, subj_list):
		"""
		Read in a subject list.  This assumes "subj_list" is a text file with each subject id number on a new line.
		
		The data read in here is passed to gen_samples and gen_melodic_list.
		"""
		if len(self.subjs) > 0:
			print 'WARNING:		It appears read_subj_list has already been run.  To prevent problems, subject list has been reset...this is only a warning.'
			self.subjs = []
		sl = open(subj_list, 'r')
		for line in sl:
			if not str(line).replace('\n', '') == '':
				self.subjs.append(str(line).replace('\n', ''))
	
	def gen_samples(self, nSamples, N):
		"""
		Script to generate a list of of random subject ids.
		
		Within this list, you have nSamples lists.  Each nSamples list holds N subjects.
		
		nSamples = the number of lists of random subjects you want
		N = the number of subjects per list.
		
		"""
		nSubjs = len(self.subjs)
		if len(self.samples) > 0:
			print 'WARNING:		It appears gen_samples has already been run.  To prevent problems, samples list has been reset....this is only a warning.'
			self.samples = []
		for n in range(0, nSamples):
			sample_subjs = []
			while len(sample_subjs) < N:
				rand_int = random.randint(0, nSubjs-1)
				try:
					sample_subjs.index(self.subjs[rand_int])
				except:
					sample_subjs.append(self.subjs[rand_int])
			self.samples.append(sample_subjs)
	
	def gen_melodic_lisa(self, fmri_dir, feat_sfix, melodic_sample_dir, samples_sfix):
		"""
		Will generate text files to feed the melodic command line utility with a list of filtered func data from feat.
		
		Args:
		
		fmri_dir = where the feat processed fmri datasets are located.  This assumes the following directory hierarchy:
			feat_dir/subject/subject.feat
		
		feat_sfix = The naming convention for the feat folder within the subject folder.  This assumes the folder starts with the subject id.
			feat_sfix = 1_Apr2013.feat, where "1" is the subject id number.
		
		melodic_sample_dir = where the subject lists for melodic will be saved out.
		
		samples_sfix = the suffix to be used for the above mentioned subject lists.
			
		"""
		nSamples = len(self.samples)
		for s in range(0, nSamples):
			odir = os.path.join(melodic_sample_dir, 'sample.' + str(s) + '.' + samples_sfix)
			if not os.path.exists(odir):
				os.makedirs(odir)
			oFile = os.path.join(melodic_sample_dir, 'sample.' + str(s) + '.' + samples_sfix, 'sample.' + str(s))
			if not os.path.exists(oFile):
				f = open(oFile, 'w')
				for l in self.samples[s]:
					f.write(os.path.join(fmri_dir, str(l),  str(l) + feat_sfix, 'filtered_func_data_2_standard.nii.gz' + '\n'))
				f.close()
			else:
				print 'WARNING:		Output file: ', oFile, '  Already exists...will not overwrite! Please remove existing files, change your output suffix, or change the output folder.'
	


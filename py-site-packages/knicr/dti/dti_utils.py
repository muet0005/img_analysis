import os as os
import sys as sys
import csv as csv
import numpy as np
from nibabel import nifti1 as nii
import nipype.interfaces.fsl as fsl
import socket as socket
import datetime as datetime
import argparse as argparse


__author__ = "Ryan Muetzel"
__license__ = "GPL"
__version__ = "0.1"



def write_log(cmd, oFile):
    """
    write_log
    Simple function to track data provenance via the nipype package
    
    Arguments:
    cmd: usually the nipype function.cmdline
    
    oFile: the file you want to write the logging to.
    """
    if os.path.exists(oFile):
        f = open(oFile, 'a')
    else:
        f = open(oFile, 'w')
    f.write('#######--------NEW INSTANCE CALLED--------#######' + '\n')
    f.write('timestamp=' + datetime.datetime.now().strftime('%d%b%Y_%H:%M:%S') + '\n')
    f.write('user=' + os.getlogin() + '\n')
    f.write('pwd=' + os.getcwd() + '\n')
    f.write('domainname=' + socket.getfqdn() + '\n')
    f.write('hostname=' + socket.gethostname() + '\n')
    f.write('osUname=' + str(os.uname()) + '\n')
    f.write('PythonVersion=' + sys.version + '\n')
    f.write(cmd + '\n')
    f.write('#######--------END OF LOG--------#######' + '\n')
    f.close()



class knicrTBSS():
    """
    knicrTBSS 
    
    A class of functions to run FSLs TBSS module in a stepwise fashion
    
    ...more to come...
    """
    def __init__(self, tbssDir, template):
        self.tbssDir = tbssDir
        self.faDir = os.path.join(self.tbssDir, 'FA')
        self.template = template
        if not os.path.exists(self.faDir):
            os.makedirs(self.faDir)
    
    def tbss_1_preproc(self, dtiDir, subject, **kwargs):
        """
        tbss_1_preproc
        
        An adaptation from FSLs tbss_1_preproc: $FSLDIR/bin/tbss_1_preproc
        
        dtiDir is the location of your DTI data. The default is to assume FreeSurfer's TRACULA
        has been run first. It will look for dtifit_FA.nii.gz in $dtiDir/subject/dmri
        
        !!!Changes from the FSL version!!!
        Some zero-padding is done in FSL, presumably to speed up the nonlinear registration. This is skipped here!
        """
        self.subject = subject
        tracula_format=True
        #add in some kwarg functionality here to allow for alternative formats as inputs.
        if tracula_format:
            fa=os.path.join(dtiDir, subject, 'dmri', 'dtifit_FA.nii.gz')
        else:
            fa=False
        if not os.path.exists(str(fa)):
            print 'Cannot locate FA map: '
            print 'dtiDir: ', dtiDir
            print 'Subject: ', subject
            print 'fa: ', fa
            return
        print 'Processing: ', subject
        #first we need to erode the FA map a bit, to get rid of the high signal voxels around the edges
        logFile = os.path.join(self.faDir, 'idc_' + subject + '.tbss_1_preproc.log')
        self.fa = os.path.join(self.faDir, 'idc_' + subject + '_FA.nii.gz')
        if not os.path.exists(self.fa):
            fslmaths = fsl.ImageMaths(in_file=fa, op_string='-ero', out_file=self.fa, output_type='NIFTI_GZ', out_data_type='float')
            fslmaths.run()
            write_log(fslmaths.cmdline, logFile)
        #make a mask of the eroded file now
        self.mask = self.fa.replace('.nii.gz', '_mask.nii.gz')
        if not os.path.exists(self.mask):
            fslmaths = fsl.ImageMaths(in_file=self.fa, op_string='-bin', out_file=self.mask, output_type='NIFTI_GZ', out_data_type='float')
            fslmaths.run()
            write_log(fslmaths.cmdline, logFile)
            op_str = '-dilD -dilD -sub 1 -abs -add ' + self.mask
            fslmaths = fsl.ImageMaths(in_file=self.mask, op_string=op_str, out_file=self.mask, output_type='NIFTI_GZ', out_data_type='char')
            fslmaths.run()
            write_log(fslmaths.cmdline, logFile)
    
    def tbss_2_reg(self):
        config='FA_2_FMRIB58_1mm'
        if not os.path.exists(self.fa):
            print 'Fa map not found: ', self.fa
            print 'run tbss_1_preproc first...'
            return
        obn = os.path.join(self.faDir, os.path.basename(self.fa).replace('.nii.gz', '') + '_to_' + os.path.basename(self.template).replace('.nii.gz', '') + '_lin')
        oFile = obn + '.nii.gz'
        mat = obn + '.mat'
        logFile = os.path.join(self.faDir, 'idc_' + self.subject + '.tbss_2_reg.log')
        if not os.path.exists(oFile):
            flirt = fsl.FLIRT(in_file=self.fa, reference=self.template, out_file=oFile, in_weight=self.mask, out_matrix_file=mat)
            flirt.run()
            write_log(flirt.cmdline, logFile)
        obn = os.path.join(self.faDir, os.path.basename(self.fa).replace('.nii.gz', '') + '_to_' + os.path.basename(self.template).replace('.nii.gz', '') + '_nonlin')
        oFile = obn + '.nii.gz'
        warp = obn + '_warp.nii.gz'
        if not os.path.exists(warp):
            fnirt = fsl.FNIRT(in_file=self.fa, fieldcoeff_file=warp, affine_file=mat, config_file=config, ref_file=self.template)
            fnirt.run()
            write_log(fnirt.cmdline, logFile)
        
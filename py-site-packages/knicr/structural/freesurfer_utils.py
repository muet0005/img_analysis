import os as os
import sys as sys
import csv as csv
import pwd
import numpy as np
import shutil as shutil
import nibabel as nb
from nibabel import nifti1 as nii
import nipype.interfaces.fsl as fsl
import nipype.interfaces.freesurfer as freesurfer
from nipype.interfaces.base import Undefined
import subprocess as sp
import socket as socket
import datetime as datetime
import argparse as argparse
import MySQLdb as mysqldb


__author__ = "Ryan Muetzel"
__license__ = "GPL"
__version__ = "0.2"


class qdec_clusters():
    def __init__(self, subjects_dir):
        """
        Required Arguments:
            subjects_dir = location of freesurfer data foldres.
        """
        self.subjects_dir = subjects_dir
        self.exclude = ('knicr', 'fsaverage')
        
        os.environ['SUBJECTS_DIR'] = subjects_dir
    
    def mapQdecLabel2Subjects(self, label, hemi, **kwargs):
        """
        Use mri_label2label to map label file from qdec to each subject.
        
        Required arguments:
            
            label = full path to the + name of the label file.
            
            hemi = hemisphere. lh or rh.
        
        Optional arguments:
            
            fsaverage = default is fsaverage. can specify custom template. Wherever the label was drawn on.
            
            regmethod. default is surface. volume is option as well.
             
            subjects. List type. If you want to run on a subset.  Otherwise, the default to to use the full subjects_dir listing.
            
            overwrite. boolean. if specified, label files existing in subject folder will be overwritten. otherwise skipped. default is False.
            
        """
        subjects = os.listdir(self.subjects_dir)
        measure = 'thickness'
        fsaverage = 'fsaverage'
        regmethod = 'surface'
        overwrite = False
        for i in kwargs.keys():
            if i == 'measure':
                measure = kwargs[i]
            elif i == 'fsaverage':
                fsaverage = kwargs[i]
            elif i == 'regmethod':
                regmethod = kwargs[i]
            elif i == 'overwrite':
                overwrite = True
            elif i == 'subjects':
                if type(kwargs[i]) is list:
                    subjects = kwargs[i]
        for s in subjects:
            if s.startswith(self.exclude) or not os.path.exists(os.path.join(self.subjects_dir, s, 'label')):
                #get rid of the riff raff
                continue
            if os.path.exists(os.path.join(self.subjects_dir, s, 'label', os.path.basename(label) + '.label')):
                if not overwrite:
                    continue
            label2label = freesurfer.MRILabel2Label(srclabel=label, srcsubject=fsaverage, trgsubject=s, trglabel=os.path.basename(label), hemi=hemi, regmethod=regmethod)
            label2label.run()
    
    def computeQdecLabelStats(self, label, hemi, **kwargs):
        """
        Required Arguments:
            label. Just give the full path to the original qdec label. I'll figure out the rest.
            
            hemi = lh or rh
        
        Optional Arguments:
        Measure: This is the kind of stats to extract. Options are thickness, lgi, and area.
            The default is thicknes. However, the area measure here is white matter surface area. If area is specified, pial surface area is extracted.
        """
        subjects = os.listdir(self.subjects_dir)
        measure = 'thickness'
        overwrite = False
        for i in kwargs.keys():
            if i == 'measure':
                measure = kwargs[i]
            elif i == 'overwrite':
                overwrite = True
            elif i == 'subjects':
                if type(kwargs[i]) is list:
                    subjects = kwargs[i]
        for s in subjects:
            labelfile = os.path.join(self.subjects_dir, s, 'label', os.path.basename(label) + '.label')
            if not os.path.exists(labelfile) or s.startswith(self.exclude):
                print 'skipping: ', labelfile
                continue
            oFile = os.path.join(self.subjects_dir, s, 'stats', os.path.basename(label) + '.' + measure + '.stats')
            if os.path.exists(oFile):
                if not overwrite:
                    continue
            stats = freesurfer.MRISAnatomicalStats(labelfile=labelfile, tabular=True, tablefile=oFile, hemi=hemi, subject=s)
            if measure == 'thickness':
                stats.inputs.thicknessfile = hemi + '.thickness'
            elif measure == 'lgi':
                stats.inputs.thicknessfile = hemi + '.pial_lgi'
            elif measure == 'area':
                stats.inputs.surface = 'pial'
            stats.run()
    
    def dumpQdecLabelStatsMysql(self, cursor, label, hemi, **kwargs):
        tblroot = 'qdec_label_'
        id_col = 'idc'
        measure = 'thickness'
        subjects = os.listdir(self.subjects_dir)
        for i in kwargs.keys():
            if i == 'tblroot':
                tblroot = kwargs[i]
                print 'Resetting table root name to: ', tblroot
            elif i == 'id_col':
                id_col = kwargs[i]
                print 'Resetting table ID column to: ', id_col
            elif i == 'measure':
                measure = kwargs[i]
                print 'Resetting measure to be: ', measure
        tbl = tblroot + os.path.basename(label).replace('.', '_').replace('-', '_') + '_' + measure    
        try:
            cursor.execute("""create table %s (%s int)""" % (tbl, id_col))
        except:
            pass

        for s in subjects:
            if s.startswith(self.exclude):
                continue
            #specify the file to read in
            stats_file = os.path.join(self.subjects_dir, s, 'stats', os.path.basename(label) + '.' + measure + '.stats')
            if not os.path.exists(stats_file):
                continue
            #check the table to see if the subject exists
            cursor.execute("""select %s from %s where %s=\'%s\'""" % (id_col, tbl, id_col, s))
            pn_exist = cursor.fetchone()
            if not pn_exist:
                cursor.execute("""insert into %s (%s) values (\'%s\')""" % (tbl, id_col, s))
            statsFile = open(stats_file, 'r')
            stats_csv = csv.reader(statsFile, delimiter=' ')
            for row in stats_csv:
                if row[0] != '#':
                    for i in range(0, len(row)):
                        try:
                            row.index('')
                            row.remove('')
                        except:
                            continue
                        roi = row[0]
                        val_std = False
                        if measure == 'thickness':
                            val = row[4]
                            val_std = row[5]
                            col = roi.replace('.', '_') + '_thickavg'
                            col_std = roi.replace('.', '_') + '_thickavg_std'
                        elif measure == 'lgi':
                            val = row[4]
                            val_std = row[5]
                            col = roi.replace('.', '_') + '_lgi'
                            col_std = roi.replace('.', '_') + '_lgi_std'
                        elif measure == 'area':
                            val = row[2]
                            col = roi.replace('.', '_') + '_gsuarea'
                        print val
                        val = float(val)
                        try:
                            cursor.execute("""alter table %s add column (%s double)""" % (tbl, col))
                        except:
                            pass
                        cursor.execute("""update %s set %s=%s where %s=\'%s\'""" % (tbl, col, val, id_col, s))
                        if val_std:
                            try:
                                cursor.execute("""alter table %s add column (%s double)""" % (tbl, col_std))
                            except:
                                pass
                            cursor.execute("""update %s set %s=%s where %s=\'%s\'""" % (tbl, col_std, val_std, id_col, s))
            statsFile.close()
    




                